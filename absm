#!/bin/sh

# Name: absm or A Btrfs Snapshots Manager

# This script has been written from scratch and dedicated to the public
# domain by its author: Didier Spaier, Paris.

# Anyone is free to copy, modify, publish, use, sell, or distribute it
# for any purpose, commercial or non-commercial, and by any means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org/>

# This script provide an accessible to the blind and easy to use btrfs snapshots manager, mostly
# intended to allow booting and restoring a system in its previous state if can't boot or does not
# work as expected otherwise. The first boot entries are associated with a hot key bearing their
# number (most recent first) so users can just press this key to boot a wanted snapshot.

# Each snapshots bear as as name its creation date, and all creations, deletions and restorations
# are logged.

# To know more, read or run the script. :-)

# TODO:
# check discrepancies between display_snapshots and "btrfs sub list -s /"
# Include a "good-bye" function that cleans the house.
# Add a function that compare two subvolumes

# The directive below for https://www.shellcheck.net/wiki/SC1090 -- ShellCheck can't follow non-const...
# shellcheck source=/dev/null

#------ No edit should be necessary beyond this line ---------------------------------------------#

ROOT_SUBVOL="$(grep ' / ' /etc/fstab|sed 's;.*subvol=;;;s;,.*;;')"
# TODO: write another script to manage snapshots of /home (GRUB not involved then).
# The aim would be to recover a deleted file, or the previous state of a file,
# rather than restoring the subvolume.
#HOME_SUBVOL="$(findmnt -no source /home|sed "s@.*/@@;s@]@@")"
OS_NAME=$(grep "^NAME" /etc/os-release|cut -d"=" -f2)

# The boot entries for the snapshots should be updated after a creation, deletion or restoration.
# In this aim, disable Ctl+C while we are running.
trap "" INT

#
# Auxiliary functions
#
to_lower() {
	echo "$1"|tr '[:upper:]' '[:lower:]'
}
epoch_time() {
	date +%s
}
# Separate the date and time using a non-breaking space (U+00A0) so that the current time
# be a single word.
current_time() {
	date "+%Y-%m-%d:%Hh%M"
}
log() {
	currenttime=$(current_time)
	printf %b "$currenttime ${1}\n" >> "$LOGFILE"
}
#
# Initialization
#
check_specs() {
	[ "$(id -u)" -ne 0 ] && echo "Please run this program as root or using sudo." && exit
	MISSING=/run/$(epoch_time)
	while true; do
		unset GRUB
		if command -v grub-install 1>/dev/null ; then
			GRUB=grub
		elif command -v grub2-install 1>/dev/null ; then
			GRUB=grub2
		else
			echo "grub is missing." >> "$MISSING" && break
		fi
		[ ! -f /boot/"$GRUB"/grub.cfg  ] && echo "You need to generate /boot/$GRUB/grub.cfg first." >> "$MISSING"
		if ! findmnt / -no FSTYPE|grep -q btrfs; then
			echo "The root partition does not contain a btrfs file system." >> "$MISSING" && break
		fi
		! command -v btrfs 1>/dev/null && echo "btrfs-progs is missing." >> "$MISSING" && break
		break
	done
	if [ -s "$MISSING" ]; then
		echo "This script can't be used for this reason:"
		cat "$MISSING"
		printf "Press Enter to quit "
		read -r
		rm -f "$MISSING"
		trap - INT
		exit	
	fi
	# w3m is a very accessible to the blind browser and pager.
	# We use it if available to allow navigating in an output, else use less is available,
	# else just display it with cat.
	HAVE_W3M=$(command -v w3m)
	HAVE_LESS=$(command -v less)
}
set_paths() {
	# All snapshots taken will be stored in "$MOUNTPOINT"/.snapshots, named $(current_time) and
	# the associated metadata (used to build a boot entry for each) stored in a file bearing the
	# same name in "$MOUNTPOINT"/.snapshots/ $(current_time)/var/lib/snapshot_metadata.
	# "$MOUNTPOINT"/.snapshots is created on top of the volume and created if need be.
	MOUNTPOINT=$(mktemp -d)
	echo "$MOUNTPOINT" > /tmp/MOUNTPOINT
	ROOTDEV=$(df --output=source,target|grep /$|cut -d" " -f1)
	mount "$ROOTDEV" "$MOUNTPOINT" -o subvolid=0
	LOGFILE="$MOUNTPOINT"/.snapshots/log
	mkdir -p "$MOUNTPOINT"/.snapshots
	chmod 750 "$MOUNTPOINT"/.snapshots
}
write_grub_hook() {
	# The content of the file 80_snapshots will be appended by grub-mkconfig to
	# /boot/"$GRUB"/grub.cfg thus the GRUB menu will include a boot entry for each created snapshot
	# listed in /boot/"$GRUB"/snapshots.cfg, written by the function write_snapshots_cfg.
if [ ! -f /etc/grub.d/80_snapshots ]; then
	cat<<-'eof'>/etc/grub.d/80_snapshots
	cat<<EOF
	 if [ -f  \${config_directory}/snapshots.cfg ]; then
	    source \${config_directory}/snapshots.cfg
	elif [ -z "\${config_directory}" -a -f  \$prefix/snapshots.cfg ]; then
	    source \$prefix/snapshots.cfg
	fi
	EOF
	eof
	chmod 755 /etc/grub.d/80_snapshots
fi
! grep -q snapshots.cfg  /boot/$GRUB/grub.cfg && echo "You need to regenerate /boot/$GRUB/grub.cfg before using this program." && closing
}
write_features() {
	temps=$(epoch_time)
	features=/run/"$temps"
	cat <<-EOF> "$features"
	PRESENTATION
	
	This script allows to take snapshots of the root subvolume of a system
	mounted as /, allowing to boot off one of them from the GRUB boot menu,
	and also to rollback the system restoring one of them.

	It require that the directories / and /home be mounted as btrfs subvolumes.
	Currently it takes snapshots of / as a whole, /home excluded.
	
	The snapshots can be created on demand running the script on the command line,
	or by another script running it to create snapshots upon events like after
	booting or before a package update, or periodically through a cron job.

	WARNING
	As the snashots are stored in the same file system as the root subvolume, this
	script does not protect against a hardware failure. This is not a backup tool!
	For that you could use btrbk, that can make incremental backups of / and /home
	using btrfs features.
	
	FEATURES
	If run without argument, this command starts by making some checks, then if
	successful greets the user in a menu with entries allowing to:
	. Create a snapshot.
	. Delete a snapshot.
	. Rollback the system to a previous state, recorded in a snapshot.
	. List the existing snapshots.
	. Display the GRUB boot menu including the snapshots, as it will appear after
	  a reboot. Note: in some cases le menu displayed can differ from the one
	  appearing after a reboot.
	. Display this file.
	. Display how to use snapshots and manage rollbacks.
	. View the log of creations, deletions and restorations of snapshots.
	
	The menu is context-driven: it does not propose to delete, list or restore
	snapshots is there is none. If run from a snapshot it only allows to display
	the GRUB boot menu or restore this snapshot.
	
	All creations, deletions and restorations of snapshots are logged.
	
	The command "absm c" creates a new snasphot unattended, usually from a script.
	Then if the variable SHORTDESC is set, its value is displayed in the entry for
	this snapshot in the GRUB boot menu. If the variable LONGDESC is set it is
	displayed in the log.
	
	A new snapshot is always taken just before a rollback of the system so that
	it can be reverted.

	LINKS
	https://btrfs.readthedocs.io/en/latest/
	https://digint.ch/btrbk/
	EOF
}
write_rollbacks() {
	rollbacks=/run/$((temps + 1))
	cat <<-EOF> "$rollbacks"
	HOW-TO USE SNAPSHOTS AND MANAGE ROLLBACKS

	You can use snapshots to gather from one of them files or directories to replace
	ones accidentally deleted or damaged, or to rollback the system to a previous
	state, if it is the only or easiest way to repair it.

	Restoring a snashot triggers a global rollback of the system (/home excluded)
	including files that should stay up to date, like databases or web servers.

	For this reason, just after a rollback it may also be necessary to replace
	files by up to date ones stored in the snapshot taken just before the rollback,
	even more so if the restored snaphot was old. Alternatively you can decide to
	exclude from the snapshots directories containing files that should be kept
	up to date, provided that they be not part of the core system.
	
	SELECTIVELY REPLACE FILES OR DIRECTORIES BY UP TO DATE ONES

	This can be done at any time, including just after a rollback.
	
	If done after a rollback we recommend that you do the rollback, restoring a
	snapshot, then immediately reboot so that the system be in a clean state,
	and only then do the needed replacements.
	
	You will need to identify the new snapshot taken just before the roollback,
	case occuring, more generally the most recent one, from which you will copy
	files or directories into the running system as necessary.

	To do that, just run this script and choose "list the snaphots."
	Example of output below:
	
	List of the snapshots in your Slint system:
	snapshot 1 [2024-05-14:22h10] (before restoration of 2024-05-08:21h20)
	snapshot 2 [2024-05-13:21h26] (with extra and testing)
	snapshot 3 [2024-05-08:21h42] (with extra but not testing)
	
	The snapshot 1, dated 2024-05-14:22h10, is the most recent.
	
	To access it, first mount the root partition (/dev/sda3 in the example
	below) at the top level of the btrfs volume, like this (as root):
	root[~]# mount /dev/sda3 /mnt

	The snapshots are stored  in the directory /mnt/.snapshots, named
	by their date, so the path to the snapshot 1 is:
	/mnt/.snapshots/2024-05-14:22h10
	
	You can view a file in it, for instance /etc/fstab, typing:
	cat /mnt/.snapshots/2024-05-14:22h10/etc/fstab
	and compare with the older version you have restored typing:
	cat /etc/fstab
	
	Then you can either edit the file in the running system or copy the one
	from the snapshot into the running system.
	
	You can also copy whole directories. For instance to fastly copy the whole
	/var directory you can type as root:
	mv /var /var.bak
	cp -a --reflink=always /mnt/.snapshots/2024-05-14:22h10/var  /
	# Now, check the content of /var.  if OK type:
	rm -r /var.bak

	EXCLUDE DIRECTORIES FROM THE SNAPSHOTS

	NOTE: The options of the mount commands below could need adpatations
	to the system or distribution in use. Looking at the mount options
	of / in /etc/fsab can give a clue on that.
	
	Let's assume that you to want to exclude from snapshots the
	directory /var. If not already done, type as root:
	root[~]# mount /dev/sda3 /mnt
	
	Then, still as root create a subvolume for /var:
	btrfs subvol create /mnt/@var
	
	Copy all the content of /var into this subvolume:
	cp -a --reflink=always /var/* /mnt/@var

	Backup /var, just in case.
	mv /var /var.bak
	mkdir /var
	
	Now mount /var as a subvolume. For instance:
	mount /dev/sda3 /var -o subvol=@var,compress=zstd:3,discard=async,noatime

	Now, check carefully the content of /var. Only if and when OK type:
	rm -r var.bak

	To have /var mounted at each boot, as now needed, append this line to /etc/fstab:
	UUID=<uuid of / > /var brfs subvol=@var,compress=zstd:3,discard=async,noatime 0 0
	
	Do not forget to do that before a reboot!
	Then at each boot, /var will be mounted as subvolume, separately from /.
	
	Note: the UUID of / (actually, its file system) is the output of:
	findmnt -no uuid /
	EOF
}
	
rollbacks() {
	clear
	if [ "$HAVE_W3M" ]; then
		echo >> "$rollbacks" 
		echo "Press q to go back to the menu." >> "$rollbacks"
		w3m -o confirm_qq=false "$rollbacks"
	elif [ "$HAVE_LESS" ]; then
		echo >> "$rollbacks" 
		echo "Press q to go back to the menu." >> "$rollbacks"
		less "$rollbacks"
	else
		cat "$rollbacks"
		printf "Press Enter to go back to the menu "
		read -r ANSWER
	fi
	clear
}
#
# Other functions
#
features() {
	clear
	if [ "$HAVE_W3M" ]; then
		echo >> "$features" 
		echo "Press q to go back to the menu." >> "$features"
		w3m -o confirm_qq=false "$features"
	elif [ "$HAVE_LESS" ]; then
		echo >> "$features" 
		echo "Press q to go back to the menu." >> "$features"
		less "$features"
	else
		cat "$features"
		printf "Press Enter to go back to the menu "
		read -r ANSWER
	fi
	clear
}
write_snapshots_cfg() {
	# This function is called as soon as the script is started, even if no action is taken and
	# also when the user quits, to make sure the boot entries displayed in the GRUB menu stay in
	# sync with the "on demand" snapshots it manages.
	# For each snapshot written by this script we write a boot entry in /boot/"$GRUB"/snapshots.cfg
	# including the values of the variables set sourcing this file.
	rm -f /boot/"$GRUB"/snapshots.cfg
	SNAP_NUMBER=0
	find "$MOUNTPOINT"/.snapshots -type d -maxdepth 1 -mindepth 1|sort -r|while read -r i; do
		unset INITRAMFS
		. "$i"/var/lib/snapshot_metadata
		SNAP_NUMBER=$((SNAP_NUMBER + 1))
		if [ "$INITRAMFS" ]; then
			# If the patch to the kernel in /proc/cmdline includes a prefix after "linux" and
			# before / we need to include it also in the path to the initramfs, as we assume that
			# they live in the same directory. This can happen for instance is /boot is in its own
			# partition with an ext4 file system, as in Fedora 37.
			INITRD_PREFIX="/.snapshots/$SNAP_NAME/boot"
			KERNEL_PREFIX="$(echo "$CMDLINE"|cut -d/ -f1)"
			[ "$KERNEL_PREFIX" ] && INITRD_PREFIX="$KERNEL_PREFIX"
			cat<<-eof>>/boot/"$GRUB"/snapshots.cfg
			menuentry 'snapshot $SNAP_NUMBER [$SNAP_NAME] (${SNAP_SHORT_DESC})' --hotkey=$SNAP_NUMBER {
				insmod part_gpt
				insmod part_msdos
				insmod btrfs
				insmod all_video
				echo 'Loading kernel: $KVER ...'
				linux $CMDLINE
				echo 'Loading initramfs: $INITRAMFS ...'
				initrd $INITRD_PREFIX/$INITRAMFS
			}
			eof
		else
			cat<<-eof>>/boot/"$GRUB"/snapshots.cfg
			menuentry 'snapshot $SNAP_NUMBER [$SNAP_NAME] (${SNAP_SHORT_DESC})' --hotkey=$SNAP_NUMBER {
				insmod part_gpt
				insmod part_msdos
				insmod btrfs
				insmod all_video
				echo 'Loading kernel: $KVER ...'
				linux $CMDLINE
			}
			eof
		fi
	done
}
display_grub_menu() {
	# We write in list_boot_entries the description of each boot entry listed in
	# /boot/$GRUB/grub.cfg and case occurring /boot/$GRUB/snapshots.cfg. We append a text
	# indicating how to reach a given boot entry.
	# The file $list_boot_entries, is then displayed (in w3m, used as a pager, if available).
	clear
	epoch1=$(epoch_time)
	epoch2=$((epoch1 + 1))
	listbootentries=/run/$epoch1
	listsnapshots=/run/$epoch2
	sed -n "{
		/submenu/,/^}$/ {
		/^[[:space:]]*submenu /s%[[:space:]]*[^']*'\([^']*\)'.*%\1%p
		/^[[:space:]]*\menuentry /s%[^']*'\([^']*\)'.*%  \1%p
		}
		/^[[:space:]]*\menuentry /s%[^']*'\([^']*\)'.*%\1%p
	}" /boot/grub/grub.cfg >> "$listbootentries"
	for i in $(find /boot/grub/* -prune -name "*.cfg"|grep -v grub.cfg); do
		sed -n "/^[[:space:]]*\menuentry /s%[^']*'\([^']*\)'.*%\1%p" "$i" >> "$listbootentries"
	done
	if grep -q snapshot "$listbootentries"; then
		SNAP="
To boot directly a snapshot, you can just press the key bearing its number,
if it is lower than 10.
The snapshot number 1 is the most recent.
"
	fi
	echo "
After booting, the boot menu will be displayed as above.

To navigate in the menu you will use the down and up arrow keys,
then press Enter to use the selected boot entry.
To display the boot entries inside a submenu, select it then press Enter.
$SNAP" >> "$listbootentries"
	if [ "$HAVE_W3M" ]; then
		qecho "Press q to go back to the menu." >> "$listbootentries"
		w3m -o confirm_qq=false "$listbootentries"
	elif [ "$HAVE_LESS" ]; then
		echo "Press q to go back to the menu." >> "$listbootentries"
		less "$listbootentries"
	else
		cat "$listbootentries"
		echo
		printf "Press Enter to go back to the menu "
		read -r ANSWER
	fi
	rm "$listbootentries"
	rm "$listsnapshots"
	menu
}
view_the_log() {
	if [ "$HAVE_W3M" ]; then
		echo >> "$LOGFILE"
		echo "Press q to go back to the menu." >> "$LOGFILE"
		w3m -o confirm_qq=false "$LOGFILE"
		sed  '/^$/d;$d' "$LOGFILE" > bof
		mv bof "$LOGFILE"
	elif [ "$HAVE_LESS" ]; then
		echo >> "$LOGFILE"
		echo "Press q to go back to the menu." >> "$LOGFILE"
		less "$LOGFILE"
		sed  '/^$/d;$d' "$LOGFILE" > bof
		mv bof "$LOGFILE"
	else
		cat "$LOGFILE"
		echo
		printf "Press Enter to go back to the menu "
		read -r ANSWER
	fi
	menu
}
create_snapshot() {
	NB_SNAP=0
	NB_SNAP=$(find "$MOUNTPOINT"/.snapshots -type d -maxdepth 1 -mindepth 1|wc -l)
	SNAPSHOTS="snapshots"
	[ "$NB_SNAP" -eq 1  ] && SNAPSHOTS="snapshot"
	if [ "$NB_SNAP" -ge 1  ]; then
		echo "You have already created the $SNAPSHOTS listed below:"
		display_snapshots
		echo
		printf "Type yes to create one more snapshot or Enter to go back to the menu: "
		read -r ANSWER
		[ ! "$(to_lower "$ANSWER")" = "yes" ] && menu
	fi
	KERNEL="$(sed "s|[^=]*=||;s|[ ].*||;s|.*/||" /proc/cmdline)"
	KERNEL_FOUND=$(find /boot -name "$KERNEL")
	if [ ! "$KERNEL_FOUND" ]; then
		echo "The running kernel was not found in /boot."
		echo "thus we can not create a snapshot using it."
		printf "Press Enter to go back to the menu "
		read -r ANSWER
		menu
	fi
	SNAP_NAME="$(current_time)"
	SNAP_SHORT_DESC="on demand"
	echo "By default the snapshot will be labeled \"on demand\" but you may"
	echo "type a description instead (it should have between 5 and 40 characters)."
	while true; do
		printf "Description [on demand]: "
		read -r ANSWER
		[ ! "$ANSWER" ] && break
		FORBIDDEN=$(printf %s "$ANSWER"|grep -e "[]'([)*]" -e '"')
		if [ "$(printf %s "$ANSWER"|wc -c)" -gt 40 ]; then
			echo "The description should have at most 40 characters."
		elif [ "$(printf %s "$ANSWER"|wc -c)" -lt 5 ]; then
			echo "The description should have at least 5 characters."
		elif [ "$FORBIDDEN" ]; then
			echo "The characters  [ ] ' \" ( ) are not allowed."
		else
			SNAP_SHORT_DESC="$ANSWER"
			break
		fi
	done
	btrfs subvolume snapshot "$MOUNTPOINT/$ROOT_SUBVOL" "$MOUNTPOINT"/.snapshots/"$SNAP_NAME" 1>/dev/null
	RES="$?"
	if [ "$RES" -ne 0 ]; then
		echo "snapshot creation failed"
		printf "Press Enter to go back to the menu "
		read -r ANSWER
		menu
	fi
	# We generate the metadata that will be used to include a boot entry for this snapshot in
	# /boot/grub/snapshots.cfg. They will be recorded in
	# "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib/snapshot_metadata
	mkdir -p "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib
	KVER=$(uname -r)
	unset INITRAMFS
	# We first try to find an initramfs whose name matches that of the kernel
	KERNEL="$(sed "s|[^=]*=||;s|[ ].*||;s|.*/||" /proc/cmdline)"
	KERNEL_VERSION="$(echo "$KERNEL"|cut -d- -f 2-)"
	ALL_INITRAMFS=$(find /boot/ -name "initr*${KERNEL_VERSION}*" -type f)
	CMDLINE="$(sed "
		s|[^=]*=||
		s|.*/boot|/.snapshots/$SNAP_NAME/boot|
		s|subvol=[[:graph:]]*|subvol=.snapshots/$SNAP_NAME|" /proc/cmdline)"
	[ "$ALL_INITRAMFS" ] && INITRAMFS="$(echo "$ALL_INITRAMFS"|sed "s|.*/||"|head -n 1)"
	# If no initramfs whose name includes the kernel version, try initrd.gz and initrd.img
	[ ! "$INITRAMFS" ] && [ -f /boot/initrd.gz ] && INITRAMFS=/boot/initrd.gz
	[ ! "$INITRAMFS" ] && [ -f /boot/initrd.img ] && INITRAMFS=/boot/initrd.img
	# Still not found? Try a match with uname -r
	if [ ! "$INITRAMFS" ]; then
		ALL_INITRAMFS=$(find /boot/ -name "initr*" -type f|grep "$KVER")
		[ "$ALL_INITRAMFS" ] && INITRAMFS=$(echo "$ALL_INITRAMFS"|head -n 1)
	fi
	if [ "$INITRAMFS" ]; then
		echo "SNAP_NAME=\"$SNAP_NAME\" SNAP_SHORT_DESC=\"$SNAP_SHORT_DESC\" KVER=\"$KVER\" CMDLINE=\"$CMDLINE\" INITRAMFS=\"$INITRAMFS\"" \
	> "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib/snapshot_metadata
	else
		echo "SNAP_NAME=\"$SNAP_NAME\" SNAP_SHORT_DESC=\"$SNAP_SHORT_DESC\" KVER=\"$KVER\" CMDLINE=\"$CMDLINE\"" \
	> "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib/snapshot_metadata
	fi
	[ "$LONGDESC" ] && echo "LONGDESC=\"$LONGDESC\"" >> "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib/snapshot_metadata
	write_snapshots_cfg
	log "$SNAP_NAME ($SNAP_SHORT_DESC) created"
	echo "A snapshot has been created as \"$SNAP_SHORT_DESC\""
	printf "Press Enter to go back to the menu "
	read -r ANSWER
	menu
}
create_snapshot_unattended() {
	KERNEL="$(sed "s|[^=]*=||;s|[ ].*||;s|.*/||" /proc/cmdline)"
	KERNEL_FOUND=$(find /boot -name "$KERNEL")
	if [ ! "$KERNEL_FOUND" ]; then
			log "Creation of a snapshot failed. Reason: running kernel not found in /boot."
	fi
	SNAP_NAME="$(current_time)"
	SNAP_SHORT_DESC="on demand"
	btrfs subvolume snapshot "$MOUNTPOINT/$ROOT_SUBVOL" "$MOUNTPOINT"/.snapshots/"$SNAP_NAME" 1>/dev/null
	RES="$?"
	if [ "$RES" -ne 0 ]; then
		log "Making a snapshot of the root subvolume $MOUNTPOINT/$ROOT_SUBVOL failed."
		exit
	else
		[ "$SHORTDESC" ] && SNAP_SHORT_DESC="$SHORTDESC"
		# We generate the metadata that will be used to include a boot entry for this snapshot in
		# /boot/grub/snapshots.cfg. They will be recorded in
		# "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib/snapshot_metadata
		mkdir -p "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib
		KVER=$(uname -r)
		unset INITRAMFS
		# We first try to find an initramfs whose name matches that of the kernel
		KERNEL="$(sed "s|[^=]*=||;s|[ ].*||;s|.*/||" /proc/cmdline)"
		KERNEL_VERSION="$(echo "$KERNEL"|cut -d- -f 2-)"
		ALL_INITRAMFS=$(find /boot/ -name "initr*${KERNEL_VERSION}*" -type f)
		CMDLINE="$(sed "
			s|[^=]*=||
			s|.*/boot|/.snapshots/$SNAP_NAME/boot|
			s|subvol=[[:graph:]]*|subvol=.snapshots/$SNAP_NAME|" /proc/cmdline)"
		[ "$ALL_INITRAMFS" ] && INITRAMFS="$(echo "$ALL_INITRAMFS"|sed "s|.*/||"|head -n 1)"
		# If no initramfs whose name includes the kernel version, try initrd.gz and initrd.img
		[ ! "$INITRAMFS" ] && [ -f /boot/initrd.gz ] && INITRAMFS=/boot/initrd.gz
		[ ! "$INITRAMFS" ] && [ -f /boot/initrd.img ] && INITRAMFS=/boot/initrd.img
		# Still not found? Try a match with uname -r
		if [ ! "$INITRAMFS" ]; then
			ALL_INITRAMFS=$(find /boot/ -name "initr*" -type f|grep "$KVER")
			[ "$ALL_INITRAMFS" ] && INITRAMFS=$(echo "$ALL_INITRAMFS"|head -n 1)
		fi
		if [ "$INITRAMFS" ]; then
			echo "SNAP_NAME=\"$SNAP_NAME\" SNAP_SHORT_DESC=\"$SNAP_SHORT_DESC\" KVER=\"$KVER\" CMDLINE=\"$CMDLINE\" INITRAMFS=\"$INITRAMFS\"" \
		> "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib/snapshot_metadata
		else
			echo "SNAP_NAME=\"$SNAP_NAME\" SNAP_SHORT_DESC=\"$SNAP_SHORT_DESC\" KVER=\"$KVER\" CMDLINE=\"$CMDLINE\"" \
		> "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib/snapshot_metadata
		fi
		if [ "$LONGDESC" ]; then
			echo "LONGDESC=\"$LONGDESC\"" >> "$MOUNTPOINT"/.snapshots/"$SNAP_NAME"/var/lib/snapshot_metadata
			log "$SNAP_NAME ($SNAP_SHORT_DESC\n$LONGDESC) created."
		else
			log "$SNAP_NAME ($SNAP_SHORT_DESC) created"
		fi
		write_snapshots_cfg
		closing
	fi
}
display_snapshots() {
	SNAP_NUM=0
	find "$MOUNTPOINT"/.snapshots -type d -maxdepth 1 -mindepth 1|sort -r|while read -r i; do
		. "$i"/var/lib/snapshot_metadata
		SNAP_NUM=$((SNAP_NUM + 1))
		echo snapshot "$SNAP_NUM" ["$SNAP_NAME"] \("$SNAP_SHORT_DESC"\)
	done
}
numbered_snapshots() {
	SNAP_NUM=0
	find "$MOUNTPOINT"/.snapshots -type d -maxdepth 1 -mindepth 1|sort -r|while read -r i; do
		. "$i"/var/lib/snapshot_metadata
		SNAP_NUM=$((SNAP_NUM + 1))
		echo "$SNAP_NUM|$SNAP_NAME|$SNAP_SHORT_DESC"
	done
}
list_snapshots() {
	clear
	listsnapshots=/run/$(epoch_time)
	echo "List of the snapshots in your $OS_NAME system:" > "$listsnapshots"
	display_snapshots >> "$listsnapshots"
	echo >> "$listsnapshots"
	if [ "$HAVE_W3M" ]; then
		echo "Press q to go back to the menu." >> "$listsnapshots"
		w3m -o confirm_qq=false "$listsnapshots"
	elif [ "$HAVE_LESS" ]; then
		echo "Press q to go back to the menu." >> "$listsnapshots"
		less "$listsnapshots"
	else
		cat "$listsnapshots"
		printf "Press Enter to go back to the menu "
		read -r ANSWER
	fi
	rm "$listsnapshots"
	menu
}
delete_snapshot() {
	# We allow to delete several snapshots in a row, one at a time, but not all in one shot.
	clear
	numberedsnapshots=/run/$(epoch_time)
	numbered_snapshots >"$numberedsnapshots"
	echo "List of the snapshots in your $OS_NAME system:"
	display_snapshots
	while true; do
		echo
		printf "Number of the snapshot to delete, or Enter to go back to the menu: "
		read -r NUMBER
		if [ ! "$NUMBER" ]; then
			rm "$numberedsnapshots"
			menu
		fi
		echo "$NUMBER"|grep -q "[^123456789]" && echo "$NUMBER is not a number." && continue
		# Find the name of snapshot numbered $NUMBER
		SNAP_NAME=$(sed -n "/^$NUMBER|/s@[^|]*|\([^|]*\).*@\1@p" "$numberedsnapshots")
		SNAP_SHORT_DESC=$(sed -n "/^$NUMBER|/s@.*|@@p" "$numberedsnapshots")
		[ ! "$SNAP_NAME" ] && echo "There is no snapshot number $NUMBER." && continue
		break
	done
	while true; do
		echo
		echo Delete the snapshot "$NUMBER" ["$SNAP_NAME"] \("$SNAP_SHORT_DESC"\)?
		printf "Type yes to confirm, or no to go back to the menu: "
		read -r ANSWER
		unset FAILURE
		case $(to_lower "$ANSWER") in
			yes) btrfs subvolume delete -C "$MOUNTPOINT"/.snapshots/"$SNAP_NAME" 1>/dev/null
				RET=$?
				break;;
			no) rm "$numberedsnapshots"
				menu;;
			*) :
		esac
	done
	if [ "$RET" -eq 0 ]; then
		echo
		echo "snapshot $SNAP_NAME deleted."
		write_snapshots_cfg
		rm "$numberedsnapshots"
		log "$SNAP_NAME deleted."
		printf "Press Enter to go back to the menu "
		read -r
		menu
	else
		echo "The snapshot $SNAP_NAME could not be deleted."
		log "$SNAP_NAME not deleted."
		printf "To try again to delete a snapshot type yes, else just press Enter: "
		read -r ANSWER
		[ "$(to_lower "$ANSWER")" = "yes" ] && delete_snapshot
		menu
	fi
}
restore_any_snapshot() {
	clear
	numberedsnapshots=/run/$(epoch_time)
	numbered_snapshots >"$numberedsnapshots"
	echo "List of the snapshots in your $OS_NAME system:"
	display_snapshots
	while true; do
		echo
		printf "Number of the snapshot to restore, or Enter to go back to the menu: "
		read -r NUMBER
		[ ! "$NUMBER" ] && rm "$numberedsnapshots" && menu
		echo "$NUMBER"|grep -q "[^123456789]" && echo "$NUMBER is not a number." && continue
		# Find the name of snapshot numbered $NUMBER
		SNAP_NAME=$(sed -n "/^$NUMBER|/s@[^|]*|\([^|]*\).*@\1@p" "$numberedsnapshots")
		SNAP_SHORT_DESC=$(sed -n "/^$NUMBER|/s@.*|@@p" "$numberedsnapshots")
		[ ! "$SNAP_NAME" ] && echo "There is no snapshot number $NUMBER." && continue
		break
	done
	while true; do
		echo
		echo "Restore the snapshot $NUMBER [$SNAP_NAME] ($SNAP_SHORT_DESC)?"
		printf "Type yes to confirm, or no to go back to the menu: "
		read -r ANSWER
		unset FAILURE
		case $(to_lower "$ANSWER") in
			yes)
				NEW_SNAP_NAME="$(current_time)"
				# Move the root subvolume elsewhere. This will make a snapshot of it.
				mv "$MOUNTPOINT/$ROOT_SUBVOL" "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"
				R1=$?
				if [ "$R1" -eq 0 ]; then
					# the root subvolume has been successfully snapshotted
					# Let's write its metadata.
					mkdir -p "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/var/lib
					KVER=$(uname -r)
					unset INITRAMFS
					# We first try to find an initramfs whose name matches that of the kernel
					KERNEL="$(sed "s|[^=]*=||;s|[ ].*||;s|.*/||" /proc/cmdline)"
					KERNEL_VERSION="$(echo "$KERNEL"|cut -d- -f 2-)"
					ALL_INITRAMFS=$(find /boot/ -name "initr*${KERNEL_VERSION}*" -type f)
					SNAP_SHORT_DESC="before restoration of \"$SNAP_NAME\""
					CMDLINE="$(sed "
						s|[^=]*=||
						s|.*/boot|/.snapshots/$NEW_SNAP_NAME/boot|
						s|subvol=[[:graph:]]*|subvol=.snapshots/$NEW_SNAP_NAME|" /proc/cmdline)"
					[ "$ALL_INITRAMFS" ] && INITRAMFS="$(echo "$ALL_INITRAMFS"|sed "s|.*/||"|head -n 1)"
					# If no initramfs whose name includes the kernel version,try initrd.gz and initrd.img
					[ ! "$INITRAMFS" ] && [ -f /boot/initrd.gz ] && INITRAMFS=/boot/initrd.gz
					[ ! "$INITRAMFS" ] && [ -f /boot/initrd.img ] && INITRAMFS=/boot/initrd.img
					# Still not found? Try a match with uname -r
					if [ ! "$INITRAMFS" ]; then
						ALL_INITRAMFS=$(find /boot/ -name "initr*" -type f|grep "$KVER")
						[ "$ALL_INITRAMFS" ] && INITRAMFS=$(echo "$ALL_INITRAMFS"|head -n 1)
					fi
					if [ "$INITRAMFS" ]; then
						echo "SNAP_NAME=\"$NEW_SNAP_NAME\" SNAP_SHORT_DESC=\"$SNAP_SHORT_DESC\" KVER=\"$KVER\" CMDLINE=\"$CMDLINE\" INITRAMFS=\"$INITRAMFS\"" \
					> "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/var/lib/snapshot_metadata
					else
						echo "SNAP_NAME=\"$NEW_SNAP_NAME\" SNAP_SHORT_DESC=\"$SNAP_SHORT_DESC\" KVER=\"$KVER\" CMDLINE=\"$CMDLINE\"" \
					> "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/var/lib/snapshot_metadata
					fi
					[ "$LONGDESC" ] && echo "LONGDESC=\"$LONGDESC\"" >> "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/var/lib/snapshot_metadata
					# Restore the snapshot
					mv "$MOUNTPOINT"/.snapshots/"$SNAP_NAME" "$MOUNTPOINT/$ROOT_SUBVOL"
					R2=$?
					if [ "$R2" -eq 0 ]; then
						# The restoration was successful.
						write_snapshots_cfg
						cat "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/boot/grub/snapshots.cfg > "$MOUNTPOINT"/"$ROOT_SUBVOL"/boot/grub/snapshots.cfg || exit
						echo "The snapshot .snapshots/$SNAP_NAME has been restored."
						echo "We recommend that you reboot now and in any case do not create,"
						echo  "delete or restore a snapshot before rebooting."
						log "$SNAP_NAME restored."
						touch /run/restored_snapshot
						closing
					else
						echo "The restoration failed."
						# Restore the snapshot we just made.
						log "$SNAP_NAME not restored."
						mv "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME" "$MOUNTPOINT/$ROOT_SUBVOL"
					fi
				else
					# snapshotting the root subvolume failed.
					echo "As making a new snapshot of the root subvolume failed,"
					echo "it can't be replaced by the snapshot taken on $SNAP_NAME"
					log "As making a new snapshot of the root subvolume failed,"
					log "it can't be replaced by the snapshot taken on $SNAP_NAME"
				fi
				printf "Press Enter to go back to the menu "
				read -r
				rm "$numberedsnapshots"
				menu;;
			no) rm "$numberedsnapshots"
				menu;;
			*) :
		esac
	done
}
restore_me() {
	SNAP_NAME="$RUNNING_SNAPSHOT"
	echo "Are you sure that you want to restore the snapshot dated $SNAP_NAME?"
	printf "To confirm type yes, else press Enter: "
	read -r ANSWER
	unset FAILURE
	if [ "$(to_lower "$ANSWER")" = "yes" ] ; then
		NEW_SNAP_NAME="$(current_time)"
		# Move the root subvolume elsewhere. THis will make a snapshot of it.
		mv "$MOUNTPOINT"/"$ROOT_SUBVOL" "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"
		R1=$?
		if [ "$R1" -eq 0 ]; then
			# the root subvolume has been successfully snapshotted
			# Let's write its metadata
			mkdir -p "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/var/lib
			KVER=$(uname -r)
			unset INITRAMFS
			# We first try to find an initramfs whose name matches that of the kernel
			KERNEL="$(sed "s|[^=]*=||;s|[ ].*||;s|.*/||" /proc/cmdline)"
			KERNEL_VERSION="$(echo "$KERNEL"|cut -d- -f 2-)"
			ALL_INITRAMFS=$(find /boot/ -name "initr*${KERNEL_VERSION}*" -type f)
			SNAP_SHORT_DESC="before restoration of \"$SNAP_NAME\""
			CMDLINE="$(sed "
				s|[^=]*=||
				s|.*/boot|/.snapshots/$NEW_SNAP_NAME/boot|
				s|subvol=[[:graph:]]*|subvol=.snapshots/$NEW_SNAP_NAME|" /proc/cmdline)"
			[ "$ALL_INITRAMFS" ] && INITRAMFS="$(echo "$ALL_INITRAMFS"|sed "s|.*/||"|head -n 1)"
			# If no initramfs whose name includes the kernel version,try initrd.gz and initrd.img
			[ ! "$INITRAMFS" ] && [ -f /boot/initrd.gz ] && INITRAMFS=/boot/initrd.gz
			[ ! "$INITRAMFS" ] && [ -f /boot/initrd.img ] && INITRAMFS=/boot/initrd.img
			# Still not found? Try a match with uname -r
			if [ ! "$INITRAMFS" ]; then
				ALL_INITRAMFS=$(find /boot/ -name "initr*" -type f|grep "$KVER")
				[ "$ALL_INITRAMFS" ] && INITRAMFS=$(echo "$ALL_INITRAMFS"|head -n 1)
			fi
			if [ "$INITRAMFS" ]; then
				echo "SNAP_NAME=\"$NEW_SNAP_NAME\" SNAP_SHORT_DESC=\"$SNAP_SHORT_DESC\" KVER=\"$KVER\" CMDLINE=\"$CMDLINE\" INITRAMFS=\"$INITRAMFS\"" \
			> "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/var/lib/snapshot_metadata
			else
				echo "SNAP_NAME=\"$NEW_SNAP_NAME\" SNAP_SHORT_DESC=\"$SNAP_SHORT_DESC\" KVER=\"$KVER\" CMDLINE=\"$CMDLINE\"" \
			> "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/var/lib/snapshot_metadata
			fi
			[ "$LONGDESC" ] && echo "LONGDESC=\"$LONGDESC\"" >> "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/var/lib/snapshot_metadata
			# Restore the snapshot
			mv "$MOUNTPOINT"/.snapshots/"$SNAP_NAME" "$MOUNTPOINT/$ROOT_SUBVOL"
			R2=$?
			if [ "$R2" -eq 0 ]; then
				# The restoration was successful.
				write_snapshots_cfg
				cat "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME"/boot/grub/snapshots.cfg > "$MOUNTPOINT"/"$ROOT_SUBVOL"/boot/grub/snapshots.cfg || exit
				echo "The snapshot .snapshots/$SNAP_NAME has been restored."
				echo "We recommend that you reboot now and in any case do not create,"
				echo  "delete or restore a snapshot before rebooting."
				log "$SNAP_NAME restored."
				touch /run/restored_snapshot
				closing
			else
				echo "The restoration failed."
				log "$SNAP_NAME not restored."
				# Restore the snapshot we just made.
				mv "$MOUNTPOINT"/.snapshots/"$NEW_SNAP_NAME" "$MOUNTPOINT/$ROOT_SUBVOL"
			fi
		else
			# snapshotting the root subvolume failed.
			echo "As making a new snapshot of the root subvolume failed,"
			echo "it can't be replaced by the snapshot taken on $SNAP_NAME"
			log "As making a new snapshot of the root subvolume failed,"
			log "it can't be replaced by the snapshot taken on $SNAP_NAME"
		fi
		printf "Press Enter to go back to the menu "
		read -r
		menu
	else
		menu
	fi
	
}
closing() {
	write_snapshots_cfg
	trap - INT
	exit
}
menu() {
	clear
	# From a snapshot we do not allow to create or delete a snapshot, or to restore another
	# snashot than the one in use.
	IS_SNAP=$(grep -s .snapshots /proc/cmdline)
	[ "$IS_SNAP" ] && RUNNING_SNAPSHOT=$(sed "s|.*subvol=.snapshots/||;s|[ ].*||" /proc/cmdline)
	# After having restored a snapshot we do not allow to create or delete or restore a
	# until after a reboot. We write an indicator in /run for that, so it will vanish
	# after a reboot.
	unset RESTORED
	[ -f /run/restored_snapshot ] && RESTORED="yes"
	write_snapshots_cfg
	echo "Welcome to the absm snapshots manager."
	echo
	while true; do
		echo "To choose an action, press one of the letters indicated below then Enter:"
		[ ! "$IS_SNAP" ] && [ ! "$RESTORED" ] && echo "C: Create a snapshot."
		[ ! "$IS_SNAP" ] && [ ! "$RESTORED" ] && [ -f /boot/"$GRUB"/snapshots.cfg ] && echo "D: Delete a snapshot."
		echo "F: Features of absm."
		echo "G: Display GRUB's boot menu."
		echo "H: How-to use snapshots and manage rollbacks."
		[ -f /boot/"$GRUB"/snapshots.cfg ] && echo "L: List the snapshots."
		[ ! "$IS_SNAP" ] && [ ! "$RESTORED" ] && [ -f /boot/"$GRUB"/snapshots.cfg ] && echo "R: Restore a snapshot."
		[ "$IS_SNAP" ] && [ ! "$RESTORED" ] && echo "R: Restore the snapshot in use."
		echo "V: View the log of creation, deletion and restoration of snapshots."
		printf "Your choice (or just press Enter to quit): "
		read -r ANSWER
		case $(to_lower "$ANSWER") in
			l) if [ -f /boot/"$GRUB"/snapshots.cfg ]; then list_snapshots; else menu; fi;;
			c) if [ ! "$IS_SNAP" ] && [ ! "$RESTORED" ]; then create_snapshot; else menu; fi;;
			d) if [ ! "$IS_SNAP" ] && [ ! "$RESTORED" ]; then delete_snapshot; else menu; fi;;
			f) features;;
			g) display_grub_menu;;
			h) rollbacks;;
			r) if [ ! "$RESTORED" ]; then
				if  [ ! "$IS_SNAP" ]; then
					restore_any_snapshot; menu
				else
					restore_me;
				fi
			fi;;
			v) view_the_log;;
			*) clear
			closing
		esac
	done
}
# Main
arg1="$1"
unset RESTORED
[ -f /run/restored_snapshot ] && RESTORED="yes"
case "$arg1" in
"")
	check_specs
	set_paths
	write_grub_hook
	write_features
	write_rollbacks
	menu;;
c|C)
	check_specs
	set_paths
	write_grub_hook
	create_snapshot_unattended
	echo "done"
	closing;;
esac
